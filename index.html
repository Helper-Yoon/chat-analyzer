<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNS센터 채팅분석 프로그램 v2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Malgun Gothic', '맑은 고딕', sans-serif;
            background: #000000;
            min-height: 100vh;
            padding: 20px;
            color: #FFFFFF;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #0A0A0A;
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(0, 102, 255, 0.1);
            overflow: hidden;
            border: 1px solid #1A1A1A;
        }

        .header {
            background: linear-gradient(135deg, #000000 0%, #0A0A0A 100%);
            color: white;
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #0066FF;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #FFFFFF 0%, #0066FF 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .version-badge {
            display: inline-block;
            background: #0066FF;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            color: #FFFFFF;
        }

        .main-content {
            padding: 30px;
            background: #0A0A0A;
        }

        .section {
            background: #111111;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #222222;
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: #0066FF;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.2);
        }

        .section-title {
            color: #FFFFFF;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .section-number {
            background: #0066FF;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 12px;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.5);
        }

        .file-input-wrapper {
            position: relative;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .file-display {
            flex: 1;
            padding: 12px;
            background: #000000;
            border: 1px solid #333333;
            border-radius: 8px;
            color: #999999;
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .file-button {
            background: #0066FF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .file-button:hover {
            background: #0052CC;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.5);
            transform: translateY(-1px);
        }

        input[type="file"] {
            display: none;
        }

        .date-inputs {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .date-group {
            flex: 1;
            min-width: 200px;
        }

        .date-group label {
            display: block;
            color: #999999;
            font-size: 14px;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .date-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #333333;
            border-radius: 8px;
            font-size: 14px;
            background: #000000;
            color: #FFFFFF;
            transition: border-color 0.3s ease;
        }

        .date-group input:focus {
            outline: none;
            border-color: #0066FF;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.3);
        }

        /* 날짜 선택기 다크모드 스타일 */
        .date-group input::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            color: #999999;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #333333;
            border-radius: 8px;
            font-size: 14px;
            background: #000000;
            color: #FFFFFF;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #0066FF;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.3);
        }

        .run-button {
            width: 100%;
            background: #0066FF;
            color: white;
            border: none;
            padding: 16px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.3);
        }

        .run-button:hover:not(:disabled) {
            background: #0052CC;
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 102, 255, 0.5);
        }

        .run-button:disabled {
            background: #333333;
            cursor: not-allowed;
            box-shadow: none;
            color: #666666;
        }

        .log-container {
            background: #111111;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #222222;
        }

        .log-title {
            color: #999999;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .log-content {
            background: #000000;
            border: 1px solid #333333;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 5px;
            color: #888888;
        }

        .log-entry.error {
            color: #FF3333;
            font-weight: 500;
        }

        .log-entry.success {
            color: #00FF88;
            font-weight: 500;
        }

        .log-entry.info {
            color: #0099FF;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #1A1A1A;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0066FF, #00AAFF);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.5);
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .processing {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* 스크롤바 다크모드 스타일링 */
        .log-content::-webkit-scrollbar {
            width: 8px;
        }

        .log-content::-webkit-scrollbar-track {
            background: #1A1A1A;
            border-radius: 4px;
        }

        .log-content::-webkit-scrollbar-thumb {
            background: #0066FF;
            border-radius: 4px;
        }

        .log-content::-webkit-scrollbar-thumb:hover {
            background: #0099FF;
        }

        /* 전체 스크롤바 다크모드 */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1A1A1A;
        }

        ::-webkit-scrollbar-thumb {
            background: #333333;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0066FF;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SNS센터 채팅분석 프로그램</h1>
            <span class="version-badge">v2.0</span>
        </div>

        <div class="main-content">
            <!-- 파일 선택 섹션 -->
            <div class="section">
                <div class="section-title">
                    <span class="section-number">1</span>
                    분석 파일 선택
                </div>
                <div class="file-input-wrapper">
                    <div class="file-display" id="fileDisplay">선택된 파일이 없습니다</div>
                    <button class="file-button" onclick="document.getElementById('fileInput').click()">
                        파일 찾기
                    </button>
                    <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="handleFileSelect(event)">
                </div>
            </div>

            <!-- 분석 기간 선택 섹션 -->
            <div class="section">
                <div class="section-title">
                    <span class="section-number">2</span>
                    분석 기간 선택
                </div>
                <div class="date-inputs">
                    <div class="date-group">
                        <label for="startDate">시작일</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="date-group">
                        <label for="endDate">종료일</label>
                        <input type="date" id="endDate">
                    </div>
                </div>
            </div>

            <!-- 분석 설정 섹션 -->
            <div class="section">
                <div class="section-title">
                    <span class="section-number">3</span>
                    분석 설정
                </div>
                <div class="input-group">
                    <label for="managers">관리자 목록 (쉼표로 구분)</label>
                    <input type="text" id="managers" value="이종민, 윤도우리, 김진후, 이종민, 차정환">
                </div>
                <div class="input-group">
                    <label for="exclusions">분석 제외 명단 (쉼표로 구분)</label>
                    <input type="text" id="exclusions" value="채주은, 정용욱, 한승윤, 김종현, 공현준, 강헌준">
                </div>
            </div>

            <!-- 분석 실행 버튼 -->
            <button class="run-button" id="runButton" onclick="runAnalysis()">
                <span id="buttonText">4. 분석 실행</span>
            </button>
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <!-- 진행 상황 로그 -->
            <div class="log-container">
                <div class="log-title">진행 상황 로그</div>
                <div class="log-content" id="logContent"></div>
            </div>
        </div>
    </div>

    <script>
        let selectedFile = null;
        let analysisData = null;

        // 페이지 로드 시 날짜 초기화
        window.onload = function() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
            
            document.getElementById('startDate').value = formatDate(firstDay);
            document.getElementById('endDate').value = formatDate(yesterday);
        };

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                selectedFile = file;
                document.getElementById('fileDisplay').textContent = file.name;
                document.getElementById('fileDisplay').style.color = '#FFFFFF';
                log(`파일 선택됨: ${file.name}`, 'info');
            }
        }

        function log(message, type = 'normal') {
            const logContent = document.getElementById('logContent');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString('ko-KR');
            entry.textContent = `[${time}] ${message}`;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function setProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            if (percent > 0) {
                progressBar.style.display = 'block';
                progressFill.style.width = percent + '%';
            } else {
                progressBar.style.display = 'none';
            }
        }

        async function runAnalysis() {
            if (!selectedFile) {
                alert('분석할 엑셀 파일을 먼저 선택해주세요.');
                return;
            }

            const runButton = document.getElementById('runButton');
            const buttonText = document.getElementById('buttonText');
            
            runButton.disabled = true;
            buttonText.textContent = '분석 중...';
            runButton.classList.add('processing');
            
            try {
                log('분석을 시작합니다...', 'info');
                setProgress(10);

                // 파일 읽기
                log('엑셀 파일 로딩 중...', 'info');
                const data = await readExcelFile(selectedFile);
                setProgress(30);

                // 데이터 처리
                log('데이터 정제 및 병합 중...', 'info');
                const processedData = await processData(data);
                setProgress(50);

                // 지표 계산
                log('분석 지표 계산 중...', 'info');
                const metrics = await calculateMetrics(processedData);
                setProgress(70);

                // 결과 생성
                log('결과 엑셀 파일 생성 중...', 'info');
                await createOutputExcel(metrics);
                setProgress(100);

                log('분석이 성공적으로 완료되었습니다!', 'success');
                setTimeout(() => setProgress(0), 2000);

            } catch (error) {
                log(`오류 발생: ${error.message}`, 'error');
                console.error(error);
            } finally {
                runButton.disabled = false;
                buttonText.textContent = '4. 분석 실행';
                runButton.classList.remove('processing');
            }
        }

        async function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                        
                        const sheets = {};
                        workbook.SheetNames.forEach(sheetName => {
                            const sheet = workbook.Sheets[sheetName];
                            sheets[sheetName] = XLSX.utils.sheet_to_json(sheet, { defval: null });
                        });
                        
                        log(`  - ${workbook.SheetNames.length}개 시트 로드 완료`);
                        resolve(sheets);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        async function processData(sheets) {
            // 시트 찾기
            let userChatData = null;
            let messageData = null;
            let managerData = null;

            for (const [sheetName, data] of Object.entries(sheets)) {
                const lowerName = sheetName.toLowerCase();
                if (lowerName.includes('userchat')) {
                    userChatData = data;
                } else if (lowerName.includes('message')) {
                    messageData = data;
                } else if (lowerName.includes('manager')) {
                    managerData = data;
                }
            }

            if (!userChatData || !messageData || !managerData) {
                throw new Error('필수 시트를 찾을 수 없습니다.');
            }

            // 날짜 필터링
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            endDate.setHours(23, 59, 59, 999);

            const filteredMessages = messageData.filter(msg => {
                const msgDate = new Date(msg.createdAt);
                return msgDate >= startDate && msgDate <= endDate;
            });

            log(`  - 총 ${filteredMessages.length.toLocaleString()}개의 유효 메시지 레코드 처리됨`);

            return {
                userChat: userChatData,
                messages: filteredMessages,
                managers: managerData
            };
        }

        async function calculateMetrics(data) {
            const managers = document.getElementById('managers').value.split(',').map(m => m.trim());
            const exclusions = document.getElementById('exclusions').value.split(',').map(e => e.trim());

            // 메시지 데이터 병합 및 처리
            const mergedData = [];
            
            data.messages.forEach(msg => {
                const chat = data.userChat.find(c => String(c.id) === String(msg.chatId));
                const manager = data.managers.find(m => String(m.id) === String(msg.personId));
                
                if (chat && manager) {
                    mergedData.push({
                        ...msg,
                        assigneeId: chat.assigneeId,
                        authorName: manager.name
                    });
                }
            });

            // 관리자와 상담사 분리
            const managerMessages = mergedData.filter(m => managers.includes(m.authorName));
            const agentMessages = mergedData.filter(m => 
                !managers.includes(m.authorName) && !exclusions.includes(m.authorName)
            );

            // HIR, IIF, CIS, DLS, ALS 계산
            const authorMetrics = {};
            const coreKeywords = ['월요금', '사은품', '위약금', '결합', '설치일', '설치비', 
                                 '약정', '지원금', '할인', '통신사', '요금제', '인터넷', '휴대폰'];

            // 상담사별 메트릭 계산
            const uniqueAuthors = [...new Set(agentMessages.map(m => m.authorName))];
            
            uniqueAuthors.forEach(author => {
                const authorMsgs = agentMessages.filter(m => m.authorName === author);
                const nonAssigneeMsgs = authorMsgs.filter(m => m.personId !== m.assigneeId);
                const assigneeMsgs = authorMsgs.filter(m => m.personId === m.assigneeId);
                
                const totalChats = new Set(authorMsgs.map(m => m.chatId)).size;
                const collabChats = new Set(nonAssigneeMsgs.map(m => m.chatId)).size;
                
                // HIR 계산
                const hir = totalChats > 0 ? collabChats / totalChats : 0;
                
                // IIF 계산
                const iif = nonAssigneeMsgs.length;
                
                // CIS 계산
                const cis = nonAssigneeMsgs.filter(m => 
                    coreKeywords.some(kw => m.plainText && m.plainText.includes(kw))
                ).length;
                
                // DLS 계산
                const totalLength = nonAssigneeMsgs.reduce((sum, m) => 
                    sum + (m.plainText ? m.plainText.length : 0), 0
                );
                const dls = nonAssigneeMsgs.length > 0 ? totalLength / nonAssigneeMsgs.length : 0;
                
                // ALS 계산
                const als = nonAssigneeMsgs.filter(m => 
                    m.plainText && m.plainText.includes('https://form.ajd.co.kr/')
                ).length * 10;
                
                authorMetrics[author] = {
                    name: author,
                    hir: hir,
                    iif: iif,
                    cis: cis,
                    dls: dls,
                    als: als,
                    담당상담수: new Set(assigneeMsgs.map(m => m.chatId)).size,
                    담당메시지수: assigneeMsgs.length,
                    담당글자수: assigneeMsgs.reduce((sum, m) => sum + (m.plainText ? m.plainText.length : 0), 0),
                    도움상담수: collabChats,
                    도움메시지수: nonAssigneeMsgs.length,
                    도움글자수: totalLength
                };
            });

            // 정성 점수 계산
            Object.values(authorMetrics).forEach(metrics => {
                // ALS 정규화
                const allALS = Object.values(authorMetrics).map(m => m.als);
                const minALS = Math.min(...allALS);
                const maxALS = Math.max(...allALS);
                const normALS = maxALS > minALS ? (metrics.als - minALS) / (maxALS - minALS) : 0;
                
                // 도움 정성 점수
                const helpCorrection = normALS * 3;
                metrics.도움정성점수 = metrics.도움메시지수 * (1 + helpCorrection);
                
                // 담당 정성 점수
                metrics.담당정성점수 = metrics.담당메시지수 * 0.5;
                
                // 총 정성 점수
                metrics.총정성점수 = metrics.도움정성점수 + metrics.담당정성점수;
            });

            log(`  - ${Object.keys(authorMetrics).length}명의 상담사 분석 완료`);
            
            return authorMetrics;
        }

        async function createOutputExcel(metrics) {
            const wb = XLSX.utils.book_new();
            
            // 요약 시트 생성
            const summaryData = Object.values(metrics).map(m => ({
                '상담사명': m.name,
                '담당 상담 수': m.담당상담수,
                '담당 메시지 수': m.담당메시지수,
                '담당 글자 수': m.담당글자수,
                '도움 상담 수': m.도움상담수,
                '도움 메시지 수': m.도움메시지수,
                '도움 글자 수': m.도움글자수,
                '담당 정성 점수': Math.round(m.담당정성점수 * 100) / 100,
                '도움 정성 점수': Math.round(m.도움정성점수 * 100) / 100,
                '총 정성 점수': Math.round(m.총정성점수 * 100) / 100
            }));
            
            // 총 정성 점수로 정렬
            summaryData.sort((a, b) => b['총 정성 점수'] - a['총 정성 점수']);
            
            const ws_summary = XLSX.utils.json_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, ws_summary, '채팅분석_요약');
            
            // 지표 시트 생성
            const metricsData = Object.values(metrics).map(m => ({
                '상담사명': m.name,
                '도움 개입률': Math.round(m.hir * 100) / 100,
                '개입 영향력 계수': Math.round(m.iif * 100) / 100,
                '콘텐츠 정보 점수': m.cis,
                '언어 깊이 점수': Math.round(m.dls * 100) / 100,
                '신청서 링크 점수': m.als
            }));
            
            // ALS 점수로 정렬
            metricsData.sort((a, b) => b['신청서 링크 점수'] - a['신청서 링크 점수']);
            
            const ws_metrics = XLSX.utils.json_to_sheet(metricsData);
            XLSX.utils.book_append_sheet(wb, ws_metrics, '채팅분석_지표');
            
            // 스코어보드 시트 생성
            const scoreboardData = createScoreboard(summaryData);
            const ws_scoreboard = XLSX.utils.json_to_sheet(scoreboardData);
            XLSX.utils.book_append_sheet(wb, ws_scoreboard, '스코어보드');
            
            // 도움말 시트 생성
            const helpData = [
                {
                    '구분': '정량 지표',
                    '지표명': 'HIR (도움 개입률)',
                    '정의': '한 상담사가 참여한 전체 상담 중, 협업자로 참여한 상담의 비율',
                    '산식': '협업 참여 상담 건수 / 총 참여 상담 건수'
                },
                {
                    '구분': '정량 지표',
                    '지표명': 'IIF (개입 영향력 계수)',
                    '정의': '단순 메시지 수를 넘어, 얼마나 길고 복잡한 대화에 개입했는지를 가중치로 평가',
                    '산식': 'Σ (협업 참여한 각 상담 건의 전체 메시지 수)'
                },
                {
                    '구분': '정성 지표',
                    '지표명': 'CIS (콘텐츠 정보 점수)',
                    '정의': '도움 메시지 중, 사전에 정의된 핵심 상품 키워드를 포함한 메시지의 개수',
                    '산식': 'Σ (도움 메시지 내 핵심 키워드 포함 개수)'
                },
                {
                    '구분': '정성 지표',
                    '지표명': 'DLS (언어 깊이 점수)',
                    '정의': '도움 메시지 1개당 평균 글자 길이',
                    '산식': '도움 메시지 총 글자 수 / 도움 메시지 총 개수'
                },
                {
                    '구분': '정성 지표',
                    '지표명': 'ALS (신청서 링크 점수)',
                    '정의': '도움 메시지에서 신청서 링크를 발송한 횟수에 기반한 점수',
                    '산식': 'Σ (신청서 링크 발송 횟수) * 10점'
                },
                {
                    '구분': '정성 점수',
                    '지표명': '도움 정성 점수',
                    '정의': '도움 메시지의 희소성과 ALS 보정치를 반영한 질적 기여도 점수',
                    '산식': '기본 점수 * (1 + (정규화 ALS * 3))'
                },
                {
                    '구분': '정성 점수',
                    '지표명': '담당 정성 점수',
                    '정의': '담당 메시지의 희소성 점수를 반영하고, 도움 정성 점수와의 비율을 조정한 질적 기여도 점수',
                    '산식': '기본 점수 * 비율 조정 계수'
                },
                {
                    '구분': '정성 점수',
                    '지표명': '총 정성 점수',
                    '정의': '도움 정성 점수와 담당 정성 점수의 합산',
                    '산식': '도움 정성 점수 + 담당 정성 점수'
                }
            ];
            
            const ws_help = XLSX.utils.json_to_sheet(helpData);
            XLSX.utils.book_append_sheet(wb, ws_help, '도움말');
            
            // 파일 다운로드
            const fileName = `SNS센터_채팅분석_결과_${formatDateTime()}.xlsx`;
            XLSX.writeFile(wb, fileName);
            
            log(`  - 결과 파일 생성 완료: ${fileName}`, 'success');
        }

        function createScoreboard(summaryData) {
            const scoreboardData = [];
            const metrics = ['담당 상담 수', '담당 메시지 수', '담당 글자 수', 
                           '도움 상담 수', '도움 메시지 수', '도움 글자 수',
                           '담당 정성 점수', '도움 정성 점수', '총 정성 점수'];
            
            metrics.forEach(metric => {
                // 정렬 및 상위/하위 5개 추출
                const sorted = [...summaryData].sort((a, b) => b[metric] - a[metric]);
                const top5 = sorted.slice(0, 5);
                const bottom5 = sorted.slice(-5).reverse();
                
                // 제목 행
                scoreboardData.push({
                    'Top 5': `--- ${metric} 순위 ---`,
                    '점수': '',
                    '': '',
                    'Bottom 5': '',
                    '점수 ': ''
                });
                
                // 헤더 행
                scoreboardData.push({
                    'Top 5': 'Top 5',
                    '점수': '점수',
                    '': '',
                    'Bottom 5': 'Bottom 5',
                    '점수 ': '점수'
                });
                
                // 데이터 행
                for (let i = 0; i < 5; i++) {
                    scoreboardData.push({
                        'Top 5': top5[i] ? top5[i]['상담사명'] : '',
                        '점수': top5[i] ? top5[i][metric] : '',
                        '': '',
                        'Bottom 5': bottom5[i] ? bottom5[i]['상담사명'] : '',
                        '점수 ': bottom5[i] ? bottom5[i][metric] : ''
                    });
                }
                
                // 빈 행 추가
                scoreboardData.push({
                    'Top 5': '',
                    '점수': '',
                    '': '',
                    'Bottom 5': '',
                    '점수 ': ''
                });
            });
            
            return scoreboardData;
        }

        function formatDateTime() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}_${hours}${minutes}${seconds}`;
        }
    </script>
</body>
</html>
